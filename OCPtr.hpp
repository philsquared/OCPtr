/*
 * OCPtr.hpp
 *
 * Created by Phil Nash on 06/07/2010.
 * levelofindirection.com
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * 
 */

#ifndef TBC_OCPTR_HPP_INCLUDED
#define TBC_OCPTR_HPP_INCLUDED

namespace TBC
{

// Traits for typed Objective-C classes
template<typename T>
struct OCTraits
{
    static void checkType( id p )
    {
        if( ![p isKindOfClass:[T class]] )
        {
            NSString* info = [NSString stringWithFormat:@"Attempt to store an Objective-C object of type: %@ in an OCPtr<%@>", 
                              [p class], [T description] ];
            NSException* ex = [NSException exceptionWithName:@"WrongTypeException"
                                                      reason:info
                                                    userInfo:nil];
            [ex raise];
        }
    }
    
    // In the general case we just have a typedef to T*
    // But where T==id the specialisation following kicks in
    typedef T* ObjType;
    typedef id Untyped;
};

// Traits for id type, specifically. 
template<>
struct OCTraits<id>
{
    static void checkType( id p )
    {
        OCTraits<NSObject>::checkType( p );
    }
    
    // When T == id we define our second typedef to be NSObject so we
    // can declare unambiguous constructors (as we already have an id constructor)
    typedef id ObjType;
    typedef NSObject* Untyped;
};

// Default hooks should compile away to nothing
template<typename T>
struct OCPtrHooks
{
    static void onConstruct( void* owner, id p )
    {
    }
    static void onDestroy( void* owner, id p )
    {
    }
    static void onAssign( void* owner, id oldP, id newP )
    {
    }
    static void onDetach( void* owner, id p )
    {
    }
    static void onRelease( void* owner, id p )
    {
    }
};

// Use these hooks to log retain counts
struct OCPtrLogHooks
{
    static void onConstruct( void* owner, id p )
    {
        NSLog( @"%x OCPtr(), p=%x/%d", owner, p, [p retainCount] );
    }
    static void onDestroy( void* owner, id p )
    {
        NSLog( @"%x ~OCPtr(), p=%x/%d (%@)", owner, p, [p retainCount], [p description] );
        if( [p retainCount] == 1 )
        {
            NSLog( @"%x ** %x will be dealloc'd now **", owner, p );
        }
        else if( [p retainCount] < 1 && p != nil )
        {
            NSLog( @"%x ***** %x has been over released *****", owner, p );
        }
    }
    static void onAssign( void* owner, id oldP, id newP )
    {
        NSLog( @"%x p was: %x/%d, now: %x/%d", owner, oldP, [oldP retainCount], newP, [newP retainCount] );
    }
    static void onDetach( void* owner, id p )
    {
        NSLog( @"%x detached p (%x/%d)", owner, p, [p retainCount] );
    }
    static void onRelease( void* owner, id p )
    {
        NSLog( @"%x released p (%x/%d)", owner, p, [p retainCount] );
    }
};


template<typename T>
class OCPtr
{
    typedef typename OCTraits<T>::ObjType ObjType;
    typedef typename OCTraits<T>::Untyped Untyped;
    typedef OCPtrHooks<T> HookT;
    
public:
    OCPtr()
    : m_p( nil )
    {
        HookT::onConstruct( this, nil );
    }
    
    OCPtr( ObjType p )
    : m_p( p )
    {
        HookT::onConstruct( this, p );
    }
    
    OCPtr( const OCPtr& other )
    : m_p( other.m_p )
    {
        [m_p retain];
        HookT::onConstruct( this, m_p );
    }
    
     OCPtr( Untyped p )
     : m_p( (ObjType)p )
     {
         OCTraits<T>::checkType( p );
         HookT::onConstruct( this, p );
     }

    ~OCPtr()
    {
        HookT::onDestroy( this, m_p );
        [m_p release];
    }
    
    void operator = ( const OCPtr& other )
    {
        [other.m_p retain];
        HookT::onDestroy( this, m_p );
        [m_p release];
        m_p = other.m_p;
        HookT::onConstruct( this, m_p );
    }
    
    void operator = ( const ObjType p )
    {
        HookT::onDestroy( this, m_p );
        [m_p release];
        m_p = p;
        HookT::onConstruct( this, m_p );
    }
    
    operator ObjType()
    {
        return m_p;
    }
    
    ObjType get()
    {
        return m_p;
    }
    
    ObjType autorelease()
    {
        ObjType p = [m_p autorelease];
        m_p = nil;
        return p;
    }
    
    ObjType detach()
    {
        HookT::onDetach( this, m_p );
        ObjType p = m_p;
        m_p = nil;
        return p;
    }
    
private:
    ObjType m_p;
};

typedef OCPtr<id> IdPtr;

// An example of applying log hooks to a type (in this case NSString)
template<> struct OCPtrHooks<NSString> : OCPtrLogHooks{};

} // end namespace TBC

#endif